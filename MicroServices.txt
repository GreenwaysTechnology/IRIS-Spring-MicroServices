				Micro Services
.....................................................................................
Application(software system) Develpment patterns:
.................................................

Network based Applications - Distributed Application

Application has layers:

1.User interface layer
2.Application biz layer
3.Data Layer /Repository layer
  3.1.Integration layer

Architecture of Distributed Application

1.Mainframework based distributed
   1.Application biz layer
   2.Data Layer /Repository layer
 Where as User interface layer is kept in dump terminals connected to mainframworks.

Drawbacks:
1.Too costly
2.scalability is too difficult.

Advantage:
1.High security
2.Centeralized management.

2.Client Server Architecture

2.1.Main framework based client -server , where as mainframe acts as server and digital computers act as clients.
 
2.2.Digital computer based client - server architechture
   Servers and clients are digital computers

Based on this we can classify the applications  layered /tiered concept

1.single tier/layer
   client,server,database every is kept in one single machine...
2.two tier/layer
  user interface is kept in client machine,
  data logic and biz logic is kept in server machine
 both machines are connected via networks

          "This arch based on LAN /WAN"

3.three tier /layer

 This arch based on "internet network" and web computing

   client - client machine
   server - biz logic is kept inside another machine
   database - is kept inside another machine

 Client is browser
 Server BIZ logic is kept as "web Applications"
 Database is accessed by "Server side technologies - J2EE,ASP/.net,PHP,....

4.N-tier / layer

 Client is browser
 Server BIZ logic is kept as "web Applications"
   -Again spilt into multi layered
 Database is accessed by "Server side technologies - J2EE,ASP/.net,PHP,....
.....................................................................................
		    How to build N-tier distributed Applications

Steps/Process:

1.Domain Modeling

  Banking, Online Food Delivery App, Ecommerce Domain

2.Select technology

   if your app is based on web and internet.
  Steps:
   1. Database -  Oracle 
   2. MOM - RabbitMQ,IBM MQ,Microsoft MQ
   3. Development Technology
       Java/JEE  - Why you go with specific implmentation technologies?
       .Net
       Php

3.Development and release methodology
   Waterfall -  traditional dev , release

Any domain consist of various modules
 -Accounts
 -Loans
 -Customers
 -Card
etc.....
 
4.Testing
   Once the development is over, the app is going to be under testing

5.Production
   Once the app is tested fully, ready for production.

6.Maintance
   Once the app in the production, it goes on maintaince...

if any app is built based on the above methodology, which is called as "Monolithic"

.....................................................................................
 Challanges in the application development,testing,relase,Production,maintaince

1.Every thing has to go step by step -  this increase cost , time waste,resource waste

Companies like Amazon,Netflix who wanted fast development,test,release,maintaince : Dynamic  methodology to build applications -  No downtime,
One module takes more time ,another module takes less time, because of one module , other module should not wait.

2.Technology bottleneck - Mono technology
 
 The whole application is built using single technology - Java - vendor lock
 The whole application targets single database - Oracle /Mysql/Microsoft SQL server..


3.Employing security layer is more complicated

4.Deployment / Production.

   The dev and prod env is completly different
   Bare deployment models
   VM based deployment...

...................................................................................
			  New way of building apps


1.Automatation is key concept 

   to anays,dev,test,release,prod,maintaince

Agile :(Requirement Analysis)

  Agile is an iterative approach to project management and software development that helps teams deliver value to their customers faster and with fewer headaches. Instead of betting everything on a "big bang" launch, an agile team delivers work in small, but consumable, increments

Breaks the application into smaller and smaller.
 - fast delivery with quality on time.

Requirments are highly dynamic, cant be freezed,since it is dynamic start development,test,release,deploy peridically.

We need automation, through which  automatically only we can achive fast delivery -
 in order to automate, a new technology was created "Dev Ops" - Dev + Operations togther.

Distributed source code repo - git
Pipe lines tools  - 
   Jenkins -(Continuous Integration)

Requirement---> Dev---push the code to source code repo---|CI Tool---Compile--Build/pack--Testing-Deployment(CD)

Every thing is here Continuous happens

Continuous Req Analysis
Continuous Dev 
Continuous release /build
Continuous test
Continuous release /build
Continuous deployment
Continuous tracing and monitoring

This process applied on every module in the applications
OrderManagement 
   Continuous Req Analysis,Dev,release,test,deployment,tracing,monitoring

CustomerManagement 
   Continuous Req Analysis,Dev,release,test,deployment,tracing,monitoring


if any app is built based on the above methodology, that application is called as 				  "MicroService"

....................................................................................
	     How to convert existing monolithic apps into microservices
.....................................................................................

There is a process / pattern to convert existing monolithic into microservices
                          "Scale Cube"


Scale Cube and Microservices:
............................. 
  Scale Cube is architecture pattern used to scale applications using three dimensional scalability model.

X-Axis
Z-Axis
Y-Axis

The scale defines three separate ways to scale an application.

X-axis scalling load balances requests across multiple idententical instances

Z-Axis scalling routes requests based on an attribute of the request.

X and Z scalling both are same but which different from "algorthim"


Both X and Z axis scalling improve the application's capacity and availability.

But neither approach solves the problem of increasing development and appliation complexity.


How to solve the application complexity?

 Y scalling.

Y axis scalling Functionality decomposes and an application into services:
..........................................................................
Y axis scales application into functions  or functional decomposition.

Your App
   -Y scalling
       -X or Z scalling....

A "service" is a mini application that implements narrowly focused funtionality,
Such as OrderManagement,CustomerManagment,ProductManagement  and so on...

The high level definition of microservices architecture(microservices) is an architectural style that "functionally decomposes an application into set of services(mini applcation)

In Monlolith app the app is broken into "modules" where as microservice break as services(mini application)..

What Microservices offers?

1.Microservices offers "form of modularity"
   Modualirty is essential when developing large, complex application.

2.Every Service has an "API" which is an impermeable boundary which is entry and exit   of Service

2.Each service has its own database - Customer Service may use "Mongodb'
  where as payment service may use "Oracle database"


Benefits of the microservice architecture

=> It enables the continuous delivery and deployment of large, complex applications.
=> Services are small and easily maintained.
=>Services are independently deployable.
=>Services are independently scalable.
=>The microservice architecture enables teams to be autonomous.
=>It allows easy experimenting and adoption of new technologies.
=>It has better fault isolation

....................................................................................
			How to design and implment microservices

The microservices is all about practices followed,implemented, and tested in real time production grade applications in various companies like amazon,netflix,google,microsoft.

The many community people joined togther who formed the pattern language in order to begin development of Microservices - Microservice pattern language.
.....................................................................................
			  Pattern Languages
.....................................................................................

Pattern is a resuable soultion to  a problem that occurs in a particular context.

Christopher Alexander writings inspired the software community to adopt the concept of patterns and patterns language, The book Design patterns: Elements of Resuable Object oriented Sofware - GOF patterns.

Elements of patterns.

Every Pattern has sections

1.Forces
2.Result Context
3.Related patterns

Forces: The issues that you must address when  sovling a problem.

 The forces section of a pattern describes the forces(issues) that you must address when solving a problem in a given context.

Sometimes forces can conflict, so it might not be possible to solve all of them.

Which issues(forces) are more important dependens on the context.

eg:

When you write code in a reactive style , has better performance than non reactive sync code.
But it more difficult to understand.


Resulting Context:
..................
 The force section of a pattern describes issues(forces) that must address when a solving a problem in a given context.

The result context section of a pattern describes the consequences(advantages and disadvantages) of applying the pattern.

It consistts of three parts

1.Befnifits: 
   The benefits of the pattern, including the forces that have been resolved.
2.Drawbacks:
   The drawbacks of the pattern, including, un resolved forces.
3.Issues
    The new Prolmes that have been introduced by applying the pattern.

The result ing context provides a more complete and less biased view of the solution
which enables better decisions.

Related Patterns:
 The related patterns describe the relationship between the pattern and other patterns.
 There are five types of relationship between patterns.
  

Relationships  between patterns:

Predecessor – a predecessor pattern is a pattern that motivates the need for this pattern. For example, the Microservice Architecture pattern is the predecessor to the rest of the patterns in the pattern language except the monolithic architecture pattern


Successor – a pattern that solves an issue that is introduced by this pattern. 
For example, if you apply the Microservice Architecture pattern you must then apply numerous successor patterns including service discovery patterns and the Circuit Breaker pattern.

Alternative – a pattern that provides an alternative solution to this pattern. For example, the Monolithic Architecture pattern and the Microservice Architecture pattern are alternative ways of architecting an application. You pick one or the other.

Generalization: - A Pattern that is a general soultion to a problem for eg if you want to host a service , we have different implementations like single serivce per host pattern, single service on multiple hosting etc...

Specialiation: - A specialized form of  a particular pattern -  For eg deploy a service as container pattern is spacilzation of a single service per host.
....................................................................................
		   Microservice arichitecture pattern language
...................................................................................  
The Microservice pattern language is a collection of patterns that help you architect an application using the microservice architectures.

Infrastructure Patterns:
  Thses solves problems that are mostly infrastructure issues outside of development.

Application patterns:
  These are for related to development

Application Infrastructure:
   Application related infrastructures like containers
....................................................................................
	 Patterns for Decomposing an Application into services	

1.Decompose by business capability 
	 |
	 |
2.Decompose by subdomain

3.SelfContained Service

4.Service Per Team
.....................................................................................

Common Patterns:

1.Application architecture patterns

-Monolithic architecture
-Microservice architecture

2.Decomposition -y scaling
  Decompose by business capability
  Decompose by subdomain
  Self-contained Service
  Service per team

3.Data management
->Database per Service
->Shared database
........................
->Saga
->Command-side replica
->API Composition
->CQRS
->Domain event
->Event sourcing
..........

DataBase Per Service:
.....................

Context:
 You are building microservice app.
 Services need to persit data into some kind of databases
 For eg OrderService stores data into OrderDatabase , Customer Stores data into  Customer Database

Problem:
  What is the db arch in a microservice app?

Forces: (Issues you must address when you solve a problem)

=>Services must be lossly coupled so that they can be developed,deployed and scaled independently.

=>Some business transactions must enforce invariants that span multiple services. For example, the Place Order use case must verify that a new Order will not exceed the customer’s credit limit. Other business transactions, must "update data" owned by multiple services. - Update Operation across multiple services and multiple databases

=>some business transactions need to query data that is owned by multiple services. For example, the View Available Credit use must query the Customer to find the creditLimit and Orders to calculate the total amount of the open orders -Select Data across multiple services and multiple databases

=>Some queries must join data that is owned by multiple services. For example, finding customers in a particular region and their recent orders requires a join between customers and orders = Select data across multiple data bases and services

=>Databases must sometimes be replicated and sharded in order to scale


=>Different services have different data storage requirements. For some services, a relational database is the best choice. Other services might need a NoSQL database such as MongoDB, which is good at storing complex, unstructured data, or Neo4J, which is designed to efficiently store and query graph data


Solution:
=>Keep each microservice’s persistent data private to that service and accessible only via its API. 
=>A service’s transactions only involve its database (Local Transactions)

=>The service’s database is effectively part of the implementation of that service.  It cannot be accessed directly by other services.

=>Storage options:
  1.Private-tables-per-service – each service owns a set of tables that must only be accessed by that service
  2.Schema-per-service – each service has a database schema that’s private to that service
  3.Database-server-per-service – each service has it’s own database server.


Resulting context

Advantages:
 1.Helps ensure that the services are loosely coupled. Changes to one service’s    database does not impact any other services.

 2.Each service can use the type of database that is best suited to its needs. For       example, a service that does text searches could use ElasticSearch. A service that    manipulates a social graph could use Neo4j.

DisAdvantages:
 
 1.Implementing business transactions that span multiple services is not straightforward. 
 2.Distributed transactions are best avoided because of the CAP theorem.
 3.Moreover, many modern (NoSQL) databases don’t support them.
 4.Implementing queries that join data that is now in multiple databases is challenging.
 5.Complexity of managing multiple SQL and NoSQL databases

What if i want transactions and query?

 ->How to handle distributed transactions that spwan across multiple service.
	SAGA pattern
 ->Implementing queries that span services:
	API Composition
        CQRS
....................................................................................
			Micro serivce implementations
...................................................................................

Microservice is architecture that proposes various patterns and principles, it is language, platform independant.

Java Microservices:
..................
 Java technology provides various microservices pattern implementations.

1.Spring cloud
2.Quarkus
3.Vertx
4.Akka with Microservices /Play
5.Micronaut 
etc...

Spring cloud offers many pattern implementations.
.....................................................................................
			  Service API design 
....................................................................................

API is entry and exit point of any services.

API: 
->RPI -Remote Procedure Invocation
      -WebServices
	  ->REST,SOAP
           -GraphQL
      -RPC
         gRpc
         Apache Thrift
->Messaging
    -MOM 
       RabbitMQ,MicroSoft MQ,IBM MQ,Active MQ ..
    -Streaming
       Kafka
->Domain Speficfic
   Email servies
   Media Stream -RTMP,HLS

Spring supports all types of api
 WebServices
   REST
 RPC 
  Grpc
.....................................................................................
			Spring boot with Spring cloud
.....................................................................................

Context:
  How to build Database Per Service pattern, How to handle update operations across multiple Micro Services?

Artifacts:
1.REST api using Spring MVC
2.Data Repositories using Spring JPA
3.Enabling Transactions.

Issues:
 When we build and run multiple services, some service's data update is based on other service data update - transaction

Local transaction is possible , what if i want to ensure transactions across the databases(across services)

Saga:
....
What is saga?
  Each biz transaction which spans mutiple microservices are spilt into microservice specifc local transactions and they are executed in a sequence to complex the biz work flow - It is called saga.

 A saga is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga.

. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions.


Distributed Transactions implementations:
1.2phase commit-2PC - old way , not recommended

Microservices based Transaction implementation:
...............................................
1.Choreography
2.Orchestration
.....................................................................................
			 Event Dirven Microservices
.....................................................................................

Micro Services talks via events using event channels like Kafka


Choreography-based saga:

 The state of application is captured as event.
 The event is emitted to other Services via Event Channels.

How to implement Choreography-based saga in Spring Cloud Application?

Requirements:
1.API with Repository with transactions enabled
2.Communication Channel - Transporter

Transporter:
 Any Message Brokers technology we can use
 Any Streamming platforms we can use- Recommended.

Streaming Platform:
 -Apache Kafka
 -Debezium
 -Eventuate Tram

How to integrate Streaming platforms with Spring boot application?

Spring cloud offers "Spring Cloud Stream"

Spring Cloud Stream:

 Spring Cloud Stream is a framework for building highly scalable event-driven microservices connected with shared messaging systems

Binder Implementations

1.RabbitMQ
2.Apache Kafka
3.Kafka Streams
4.Amazon Kinesis


Destination Binders: Components responsible to provide integration with the external messaging systems.

Destination Bindings: Bridge between the external messaging systems and application code (producer/consumer) provided by the end user.

Message: The canonical data structure used by producers and consumers to communicate with Destination Binders (and thus other applications via external messaging systems).

Dependencies:

<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-kafka</artifactId>
</dependency>
     <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-stream-kafka</artifactId>
</dependency>

<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-kafka-reactive</artifactId>
</dependency>


application.properties
spring.cloud.stream.kafka.binder.brokers=localhost
spring.cloud.stream.kafka.binder.defaultBrokerPort
....................................................................................
				Event Sourcing
...................................................................................
A service command typically needs to create/update/delete aggregates(rows) in the database and send messages/events to a message broker.

Saga works based on Event sourcing pattern.

For example, a service that participates in a saga needs to update business entities and send messages/events. Similarly, a service that publishes a domain event must update an aggregate and publish an event.


orchestration allows business logic to be managed and monitored in one place. Choreography, on the other hand, is the practice of orchestrating microservices together without a central coordination point.
This allows each service to operate independently while still being part of the larger architecture


...........

Use Case: 
  OrderService and Payment Service

services:
 order-service
 payment-service
 inventory-service

docker-compose.yml
version: '3'
services:
  zoo:
    image: zookeeper:3.4.9
    hostname: zoo
    ports:
      - "2181:2181"
    environment:
      ZOO_MY_ID: 1
      ZOO_PORT: 2181
      ZOO_SERVERS: server.1=zoo:2888:3888
    volumes:
      - ./zk-single-kafka-multiple/zoo/data:/data
      - ./zk-single-kafka-multiple/zoo/datalog:/datalog
  kafka1:
    image: confluentinc/cp-kafka:5.3.0
    hostname: kafka1
    ports:
      - "9091:9091"
    environment:
      KAFKA_ADVERTISED_LISTENERS: LISTENER_DOCKER_INTERNAL://kafka1:19091,LISTENER_DOCKER_EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9091
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: LISTENER_DOCKER_INTERNAL:PLAINTEXT,LISTENER_DOCKER_EXTERNAL:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: LISTENER_DOCKER_INTERNAL
      KAFKA_ZOOKEEPER_CONNECT: "zoo:2181"
      KAFKA_BROKER_ID: 1
      KAFKA_LOG4J_LOGGERS: "kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO"
    volumes:
      - ./zk-single-kafka-multiple/kafka1/data:/var/lib/kafka/data
    depends_on:
      - zoo
  kafka2:
    image: confluentinc/cp-kafka:5.3.0
    hostname: kafka2
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_LISTENERS: LISTENER_DOCKER_INTERNAL://kafka2:19092,LISTENER_DOCKER_EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: LISTENER_DOCKER_INTERNAL:PLAINTEXT,LISTENER_DOCKER_EXTERNAL:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: LISTENER_DOCKER_INTERNAL
      KAFKA_ZOOKEEPER_CONNECT: "zoo:2181"
      KAFKA_BROKER_ID: 2
      KAFKA_LOG4J_LOGGERS: "kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO"
    volumes:
      - ./zk-single-kafka-multiple/kafka2/data:/var/lib/kafka/data
    depends_on:
      - zoo
  kafka3:
    image: confluentinc/cp-kafka:5.3.0
    hostname: kafka3
    ports:
      - "9093:9093"
    environment:
      KAFKA_ADVERTISED_LISTENERS: LISTENER_DOCKER_INTERNAL://kafka3:19093,LISTENER_DOCKER_EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9093
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: LISTENER_DOCKER_INTERNAL:PLAINTEXT,LISTENER_DOCKER_EXTERNAL:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: LISTENER_DOCKER_INTERNAL
      KAFKA_ZOOKEEPER_CONNECT: "zoo:2181"
      KAFKA_BROKER_ID: 3
      KAFKA_LOG4J_LOGGERS: "kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO"
    volumes:
      - ./zk-single-kafka-multiple/kafka3/data:/var/lib/kafka/data
    depends_on:
      - zoo
  manager:
    image: sheepkiller/kafka-manager
    ports:
      - 9000:9000
    environment:
      - ZK_HOSTS=zoo:2181
    depends_on:
      - zoo
....................................................................................

OrderService work flow:

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}

Event Handlers:
...............

package com.vinsguru.order.config;

import com.vinsguru.events.inventory.InventoryEvent;
import com.vinsguru.events.payment.PaymentEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.function.Consumer;

@Configuration
public class EventHandlersConfig {

    @Autowired
    private OrderStatusUpdateEventHandler orderEventHandler;

    @Bean
    public Consumer<PaymentEvent> paymentEventConsumer(){
        return pe -> {
            orderEventHandler.updateOrder(pe.getPayment().getOrderId(), po -> {
                po.setPaymentStatus(pe.getPaymentStatus());
            });
        };
    }

    @Bean
    public Consumer<InventoryEvent> inventoryEventConsumer(){
        return ie -> {
            orderEventHandler.updateOrder(ie.getInventory().getOrderId(), po -> {
                po.setInventoryStatus(ie.getStatus());
            });
        };
    }

}

package com.vinsguru.order.config;

import com.vinsguru.events.order.OrderEvent;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

import java.util.function.Supplier;

@Configuration
public class OrderConfig {

    @Bean
    public Sinks.Many<OrderEvent> orderSink(){
        return Sinks.many().unicast().onBackpressureBuffer();
    }

    @Bean
    public Supplier<Flux<OrderEvent>> orderSupplier(Sinks.Many<OrderEvent> sink){
        return sink::asFlux;
    }

}
package com.vinsguru.order.config;

import com.vinsguru.events.inventory.InventoryStatus;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.events.payment.PaymentStatus;
import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.repository.PurchaseOrderRepository;
import com.vinsguru.order.service.OrderStatusPublisher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.util.Objects;
import java.util.UUID;
import java.util.function.Consumer;

@Service
public class OrderStatusUpdateEventHandler {

    @Autowired
    private PurchaseOrderRepository repository;

    @Autowired
    private OrderStatusPublisher publisher;

    @Transactional
    public void updateOrder(final UUID id, Consumer<PurchaseOrder> consumer){
        this.repository
                .findById(id)
                .ifPresent(consumer.andThen(this::updateOrder));

    }

    private void updateOrder(PurchaseOrder purchaseOrder){
        if(Objects.isNull(purchaseOrder.getInventoryStatus()) || Objects.isNull(purchaseOrder.getPaymentStatus()))
            return;
        var isComplete = PaymentStatus.RESERVED.equals(purchaseOrder.getPaymentStatus()) && InventoryStatus.RESERVED.equals(purchaseOrder.getInventoryStatus());
        var orderStatus = isComplete ? OrderStatus.ORDER_COMPLETED : OrderStatus.ORDER_CANCELLED;
        purchaseOrder.setOrderStatus(orderStatus);
        if (!isComplete){
            this.publisher.raiseOrderEvent(purchaseOrder, orderStatus);
        }
    }

}
...
package com.vinsguru.order.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Map;

@Configuration
public class ProductPriceConfig {

    // product price map
    @Bean
    public Map<Integer, Integer> productPrice() {
        return Map.of(
                1, 100,
                2, 200,
                3, 300
        );
    };

}
...........

controller:
package com.vinsguru.order.controller;

import com.vinsguru.dto.OrderRequestDto;
import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.service.OrderCommandService;
import com.vinsguru.order.service.OrderQueryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("order")
public class OrderController {

    @Autowired
    private OrderCommandService commandService;

    @Autowired
    private OrderQueryService queryService;

    @PostMapping("/create")
    public PurchaseOrder createOrder(@RequestBody OrderRequestDto requestDTO){
        requestDTO.setOrderId(UUID.randomUUID());
        return this.commandService.createOrder(requestDTO);
    }

    @GetMapping("/all")
    public List<PurchaseOrder> getOrders(){
        return this.queryService.getAll();
    }

}

Entity:
package com.vinsguru.order.entity;

import com.vinsguru.events.inventory.InventoryStatus;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.events.payment.PaymentStatus;
import lombok.Data;
import lombok.ToString;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Version;
import java.util.UUID;

@Data
@Entity
@ToString
public class PurchaseOrder {

    @Id
    private UUID id;
    private Integer userId;
    private Integer productId;
    private Integer price;
    private OrderStatus orderStatus;
    private PaymentStatus paymentStatus;
    private InventoryStatus inventoryStatus;

    @Version
    private int version;

}
Repository:
package com.vinsguru.order.repository;

import com.vinsguru.order.entity.PurchaseOrder;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface PurchaseOrderRepository extends JpaRepository<PurchaseOrder, UUID> {
}

........
Services:
package com.vinsguru.order.service;

import com.vinsguru.dto.OrderRequestDto;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.repository.PurchaseOrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Map;

@Service
public class OrderCommandService {

    @Autowired
    private Map<Integer, Integer> productPriceMap;

    @Autowired
    private PurchaseOrderRepository purchaseOrderRepository;

    @Autowired
    private OrderStatusPublisher publisher;

    @Transactional
    public PurchaseOrder createOrder(OrderRequestDto orderRequestDTO){
        //save order info into order table
        PurchaseOrder purchaseOrder = this.purchaseOrderRepository.save(this.dtoToEntity(orderRequestDTO));
        //once order is saved into table , publish event that order is created
        this.publisher.raiseOrderEvent(purchaseOrder, OrderStatus.ORDER_CREATED);
        return purchaseOrder;
    }

    private PurchaseOrder dtoToEntity(final OrderRequestDto dto){
        PurchaseOrder purchaseOrder = new PurchaseOrder();
        purchaseOrder.setId(dto.getOrderId());
        purchaseOrder.setProductId(dto.getProductId());
        purchaseOrder.setUserId(dto.getUserId());
        purchaseOrder.setOrderStatus(OrderStatus.ORDER_CREATED);
        purchaseOrder.setPrice(productPriceMap.get(purchaseOrder.getProductId()));
        return purchaseOrder;
    }

}

package com.vinsguru.order.service;

import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.repository.PurchaseOrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class OrderQueryService {

    @Autowired
    private PurchaseOrderRepository purchaseOrderRepository;

    public List<PurchaseOrder> getAll() {
        return this.purchaseOrderRepository.findAll();
    }

}
package com.vinsguru.order.service;

import com.vinsguru.dto.PurchaseOrderDto;
import com.vinsguru.events.order.OrderEvent;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.order.entity.PurchaseOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Sinks;

@Service
public class OrderStatusPublisher {

    @Autowired
    private Sinks.Many<OrderEvent> orderSink;

    public void raiseOrderEvent(final PurchaseOrder purchaseOrder, OrderStatus orderStatus){
        var dto = PurchaseOrderDto.of(
                purchaseOrder.getId(),
                purchaseOrder.getProductId(),
                purchaseOrder.getPrice(),
                purchaseOrder.getUserId()
        );
        //prepare OrderEvent Object so that we can send to kafka.
        var orderEvent = new OrderEvent(dto, orderStatus);
        //publish orderEvent object into kafka
        this.orderSink.tryEmitNext(orderEvent);
    }

}
application.yml
server:
  port: 8080
spring.cloud.stream:
  kafka.binder.replicationFactor: 1
  function:
    definition: orderSupplier;paymentEventConsumer;inventoryEventConsumer
  bindings:
    orderSupplier-out-0:
      destination: order-event
    paymentEventConsumer-in-0:
      destination: payment-event
    inventoryEventConsumer-in-0:
      destination: inventory-event
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>saga-choreography</artifactId>
        <groupId>com.vinsguru</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>order-service</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.vinsguru</groupId>
            <artifactId>common-dto</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>

</project>
.....................................................................................					Payment-Service
.....................................................................................
package com.vinsguru.payment;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PaymentApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentApplication.class, args);
    }

}

configuration:
package com.vinsguru.payment.config;

import com.vinsguru.events.order.OrderEvent;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.events.payment.PaymentEvent;
import com.vinsguru.payment.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.function.Function;

@Configuration
public class PaymentConfig {

    @Autowired
    private PaymentService service;

    @Bean
    public Function<Flux<OrderEvent>, Flux<PaymentEvent>> paymentProcessor() {
        return flux -> flux.flatMap(this::processPayment);
    }

    private Mono<PaymentEvent> processPayment(OrderEvent event){
        if(event.getOrderStatus().equals(OrderStatus.ORDER_CREATED)){
            return Mono.fromSupplier(() -> this.service.newOrderEvent(event));
        }else{
            return Mono.fromRunnable(() -> this.service.cancelOrderEvent(event));
        }
    }

}

Enties:
package com.vinsguru.payment.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Entity;
import javax.persistence.Id;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
public class UserBalance {

    @Id
    private int userId;
    private int balance;

}
package com.vinsguru.payment.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.UUID;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class UserTransaction {

    @Id
    private UUID orderId;
    private int userId;
    private int amount;

}

Repository:
package com.vinsguru.payment.repository;

import com.vinsguru.payment.entity.UserBalance;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserBalanceRepository extends JpaRepository<UserBalance, Integer> {
}
package com.vinsguru.payment.repository;

import com.vinsguru.payment.entity.UserTransaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface UserTransactionRepository extends JpaRepository<UserTransaction, UUID> {
}

Service:
package com.vinsguru.payment.service;

import com.vinsguru.dto.PaymentDto;
import com.vinsguru.events.order.OrderEvent;
import com.vinsguru.events.payment.PaymentEvent;
import com.vinsguru.events.payment.PaymentStatus;
import com.vinsguru.payment.entity.UserTransaction;
import com.vinsguru.payment.repository.UserBalanceRepository;
import com.vinsguru.payment.repository.UserTransactionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PaymentService {

    @Autowired
    private UserBalanceRepository balanceRepository;

    @Autowired
    private UserTransactionRepository transactionRepository;

    @Transactional
    public PaymentEvent newOrderEvent(OrderEvent orderEvent) {
        System.out.println(orderEvent.getPurchaseOrder().toString());
        var purchaseOrder = orderEvent.getPurchaseOrder();
        var dto = PaymentDto.of(purchaseOrder.getOrderId(), purchaseOrder.getUserId(), purchaseOrder.getPrice());
        return this.balanceRepository.findById(purchaseOrder.getUserId())
                .filter(ub -> ub.getBalance() >= purchaseOrder.getPrice())
                .map(ub -> {
                    ub.setBalance(ub.getBalance() - purchaseOrder.getPrice());
                    this.transactionRepository.save(UserTransaction.of(purchaseOrder.getOrderId(), purchaseOrder.getUserId(), purchaseOrder.getPrice()));
                    return new PaymentEvent(dto, PaymentStatus.RESERVED);
                })
                .orElse(new PaymentEvent(dto, PaymentStatus.REJECTED));
    }

    @Transactional
    public void cancelOrderEvent(OrderEvent orderEvent) {
        this.transactionRepository.findById(orderEvent.getPurchaseOrder().getOrderId())
                .ifPresent(ut -> {
                    this.transactionRepository.delete(ut);
                    this.balanceRepository.findById(ut.getUserId())
                            .ifPresent(ub -> ub.setBalance(ub.getBalance() + ut.getAmount()));
                });
    }
}
.........
resources
application.yml
spring.cloud.stream:
  kafka.binder.replicationFactor: 1
  function:
    definition: paymentProcessor
  bindings:
    paymentProcessor-in-0:
      destination: order-event
    paymentProcessor-out-0:
      destination: payment-event

data.sql
DROP TABLE IF EXISTS user_balance;
CREATE TABLE user_balance AS SELECT * FROM CSVREAD('classpath:user_balance.csv');

user_balance.csv
user_id,balance
1,1000
2,1000
3,1000

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>saga-choreography</artifactId>
        <groupId>com.vinsguru</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>payment-service</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.vinsguru</groupId>
            <artifactId>common-dto</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>
</project>
................................................................................
				Inventory-Service
...................................................................................
package com.vinsguru.inventory;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryApplication {

    public static void main(String[] args) {
        SpringApplication.run(InventoryApplication.class, args);
    }

}

package com.vinsguru.inventory.config;

import com.vinsguru.events.inventory.InventoryEvent;
import com.vinsguru.events.order.OrderEvent;
import com.vinsguru.events.order.OrderStatus;
import com.vinsguru.inventory.service.InventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.function.Function;

//Event listeners code
@Configuration
public class InventoryConfig {

    @Autowired
    private InventoryService service;

    @Bean
    public Function<Flux<OrderEvent>, Flux<InventoryEvent>> inventoryProcessor() {
        return flux -> flux.flatMap(this::processInventory);
    }

    private Mono<InventoryEvent> processInventory(OrderEvent event){
        if(event.getOrderStatus().equals(OrderStatus.ORDER_CREATED)){
            return Mono.fromSupplier(() -> this.service.newOrderInventory(event));
        }
        return Mono.fromRunnable(() -> this.service.cancelOrderInventory(event));
    }

}

package com.vinsguru.inventory.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Entity;
import javax.persistence.Id;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class OrderInventory {

    @Id
    private int productId;
    private int availableInventory;

}
package com.vinsguru.inventory.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.UUID;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class OrderInventoryConsumption {

    @Id
    private UUID orderId;
    private int productId;
    private int quantityConsumed;

}

repository
package com.vinsguru.inventory.repository;

import com.vinsguru.inventory.entity.OrderInventoryConsumption;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface OrderInventoryConsumptionRepository extends JpaRepository<OrderInventoryConsumption, UUID> {
}

package com.vinsguru.inventory.repository;

import com.vinsguru.inventory.entity.OrderInventory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderInventoryRepository extends JpaRepository<OrderInventory, Integer> {
}

services:
......
package com.vinsguru.inventory.service;

import com.vinsguru.dto.InventoryDto;
import com.vinsguru.events.inventory.InventoryEvent;
import com.vinsguru.events.inventory.InventoryStatus;
import com.vinsguru.events.order.OrderEvent;
import com.vinsguru.inventory.entity.OrderInventoryConsumption;
import com.vinsguru.inventory.repository.OrderInventoryConsumptionRepository;
import com.vinsguru.inventory.repository.OrderInventoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class InventoryService {

    @Autowired
    private OrderInventoryRepository inventoryRepository;

    @Autowired
    private OrderInventoryConsumptionRepository consumptionRepository;

    @Transactional
    public InventoryEvent newOrderInventory(OrderEvent orderEvent){
        InventoryDto dto = InventoryDto.of(orderEvent.getPurchaseOrder().getOrderId(), orderEvent.getPurchaseOrder().getProductId());
        return inventoryRepository.findById(orderEvent.getPurchaseOrder().getProductId())
                .filter(i -> i.getAvailableInventory() > 0 )
                .map(i -> {
                    i.setAvailableInventory(i.getAvailableInventory() - 1);
                    consumptionRepository.save(OrderInventoryConsumption.of(orderEvent.getPurchaseOrder().getOrderId(), orderEvent.getPurchaseOrder().getProductId(), 1));
                    return new InventoryEvent(dto, InventoryStatus.RESERVED);
                })
                .orElse(new InventoryEvent(dto, InventoryStatus.REJECTED));
    }

    @Transactional
    public void cancelOrderInventory(OrderEvent orderEvent){
        consumptionRepository.findById(orderEvent.getPurchaseOrder().getOrderId())
                .ifPresent(ci -> {
                    inventoryRepository.findById(ci.getProductId())
                            .ifPresent(i ->
                                i.setAvailableInventory(i.getAvailableInventory() + ci.getQuantityConsumed())
                            );
                    consumptionRepository.delete(ci);
                });
    }

}

application.yml
spring.cloud.stream:
  kafka.binder.replicationFactor: 1
  function:
    definition: inventoryProcessor
  bindings:
    inventoryProcessor-in-0:
      destination: order-event
    inventoryProcessor-out-0:
      destination: inventory-event

data.sql
DROP TABLE IF EXISTS order_inventory;
CREATE TABLE order_inventory AS SELECT * FROM CSVREAD('classpath:order_inventory.csv');

order_inventory.csv
product_id,available_inventory
1,5
2,5
3,5
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>saga-choreography</artifactId>
        <groupId>com.vinsguru</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>inventory-service</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.vinsguru</groupId>
            <artifactId>common-dto</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

    </dependencies>

</project>
.....................................................................................
			   Saga -Orchestration
.....................................................................................
	
Orchestration-based saga where the Service uses a "saga orchestrator" to orchestrate events.
Orchestration can be done by third party tools or java programs...

Saga Orchestration decouples of handling events from biz logic where choreography couples handling events and biz logic together.

saga-orchestrator microservice

application.yml

server:
  port: 8083
---
spring.cloud.stream:
  function:
    definition: processor
  bindings:
    processor-in-0:
      destination: order-created
    processor-out-0:
      destination: order-updated
  kafka:
    binder:
      replication-factor: 1
---
service:
  endpoints:
    inventory: http://localhost:8081
    payment: http://localhost:8082


package com.vinsguru.saga;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrchestratorApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrchestratorApplication.class, args);
    }

}

Config:
.......
package com.vinsguru.saga.config;

import com.vinsguru.dto.OrchestratorRequestDTO;
import com.vinsguru.dto.OrchestratorResponseDTO;
import com.vinsguru.saga.service.OrchestratorService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Flux;

import java.util.function.Function;

@Configuration
public class OrchestratorConfig {

    @Autowired
    private OrchestratorService orchestratorService;

    @Bean
    public Function<Flux<OrchestratorRequestDTO>, Flux<OrchestratorResponseDTO>> processor(){
        return flux -> flux
                            .flatMap(dto -> this.orchestratorService.orderProduct(dto))
                            .doOnNext(dto -> System.out.println("Status : " + dto.getStatus()));
    }

}

package com.vinsguru.saga.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {

    @Bean
    @Qualifier("payment")
    public WebClient paymentClient(@Value("${service.endpoints.payment}") String endpoint){
        return WebClient.builder()
                .baseUrl(endpoint)
                .build();
    }

    @Bean
    @Qualifier("inventory")
    public WebClient inventoryClient(@Value("${service.endpoints.inventory}") String endpoint){
        return WebClient.builder()
                .baseUrl(endpoint)
                .build();
    }

}
..................................................................................
Service:
package com.vinsguru.saga.service;

import com.vinsguru.dto.InventoryRequestDTO;
import com.vinsguru.dto.OrchestratorRequestDTO;
import com.vinsguru.dto.OrchestratorResponseDTO;
import com.vinsguru.dto.PaymentRequestDTO;
import com.vinsguru.enums.OrderStatus;
import com.vinsguru.saga.service.steps.InventoryStep;
import com.vinsguru.saga.service.steps.PaymentStep;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;

@Service
public class OrchestratorService {

    @Autowired
    @Qualifier("payment")
    private WebClient paymentClient;

    @Autowired
    @Qualifier("inventory")
    private WebClient inventoryClient;

    public Mono<OrchestratorResponseDTO> orderProduct(final OrchestratorRequestDTO requestDTO){
        Workflow orderWorkflow = this.getOrderWorkflow(requestDTO);

        return Flux.fromStream(() -> orderWorkflow.getSteps().stream())
                .flatMap(WorkflowStep::process)
                .handle(((aBoolean, synchronousSink) -> {
                    if(aBoolean)
                        synchronousSink.next(true);
                    else
                        synchronousSink.error(new WorkflowException("create order failed!"));
                }))
                .then(Mono.fromCallable(() -> getResponseDTO(requestDTO, OrderStatus.ORDER_COMPLETED)))
                .onErrorResume(ex -> this.revertOrder(orderWorkflow, requestDTO));

    }

    private Mono<OrchestratorResponseDTO> revertOrder(final Workflow workflow, final OrchestratorRequestDTO requestDTO){
        return Flux.fromStream(() -> workflow.getSteps().stream())
                .filter(wf -> wf.getStatus().equals(WorkflowStepStatus.COMPLETE))
                .flatMap(WorkflowStep::revert)
                .retry(3)
                .then(Mono.just(this.getResponseDTO(requestDTO, OrderStatus.ORDER_CANCELLED)));
    }

    private Workflow getOrderWorkflow(OrchestratorRequestDTO requestDTO){
        WorkflowStep paymentStep = new PaymentStep(this.paymentClient, this.getPaymentRequestDTO(requestDTO));
        WorkflowStep inventoryStep = new InventoryStep(this.inventoryClient, this.getInventoryRequestDTO(requestDTO));
        return new OrderWorkflow(List.of(paymentStep, inventoryStep));
    }

    private OrchestratorResponseDTO getResponseDTO(OrchestratorRequestDTO requestDTO, OrderStatus status){
        OrchestratorResponseDTO responseDTO = new OrchestratorResponseDTO();
        responseDTO.setOrderId(requestDTO.getOrderId());
        responseDTO.setAmount(requestDTO.getAmount());
        responseDTO.setProductId(requestDTO.getProductId());
        responseDTO.setUserId(requestDTO.getUserId());
        responseDTO.setStatus(status);
        return responseDTO;
    }

    private PaymentRequestDTO getPaymentRequestDTO(OrchestratorRequestDTO requestDTO){
        PaymentRequestDTO paymentRequestDTO = new PaymentRequestDTO();
        paymentRequestDTO.setUserId(requestDTO.getUserId());
        paymentRequestDTO.setAmount(requestDTO.getAmount());
        paymentRequestDTO.setOrderId(requestDTO.getOrderId());
        return paymentRequestDTO;
    }

    private InventoryRequestDTO getInventoryRequestDTO(OrchestratorRequestDTO requestDTO){
        InventoryRequestDTO inventoryRequestDTO = new InventoryRequestDTO();
        inventoryRequestDTO.setUserId(requestDTO.getUserId());
        inventoryRequestDTO.setProductId(requestDTO.getProductId());
        inventoryRequestDTO.setOrderId(requestDTO.getOrderId());
        return inventoryRequestDTO;
    }

}

package com.vinsguru.saga.service;

import java.util.List;

public interface Workflow {

    List<WorkflowStep> getSteps();

}

package com.vinsguru.saga.service;

import reactor.core.publisher.Mono;

public interface WorkflowStep {

    WorkflowStepStatus getStatus();
    Mono<Boolean> process();
    Mono<Boolean> revert();

}
package com.vinsguru.saga.service;

public enum WorkflowStepStatus {
    PENDING,
    COMPLETE,
    FAILED;
}

package com.vinsguru.saga.service;

public class WorkflowException extends RuntimeException {

    public WorkflowException(String message) {
        super(message);
    }

}


package com.vinsguru.saga.service;

import java.util.List;

public class OrderWorkflow implements Workflow {

    private final List<WorkflowStep> steps;

    public OrderWorkflow(List<WorkflowStep> steps) {
        this.steps = steps;
    }

    @Override
    public List<WorkflowStep> getSteps() {
        return this.steps;
    }

}



package com.vinsguru.saga.service;

import reactor.core.publisher.Mono;

public interface WorkflowStep {

    WorkflowStepStatus getStatus();
    Mono<Boolean> process();
    Mono<Boolean> revert();

}

Steps:package com.vinsguru.saga.service.steps;

import com.vinsguru.dto.InventoryRequestDTO;
import com.vinsguru.dto.InventoryResponseDTO;
import com.vinsguru.enums.InventoryStatus;
import com.vinsguru.saga.service.WorkflowStep;
import com.vinsguru.saga.service.WorkflowStepStatus;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public class InventoryStep implements WorkflowStep {

    private final WebClient webClient;
    private final InventoryRequestDTO requestDTO;
    private WorkflowStepStatus stepStatus = WorkflowStepStatus.PENDING;

    public InventoryStep(WebClient webClient, InventoryRequestDTO requestDTO) {
        this.webClient = webClient;
        this.requestDTO = requestDTO;
    }

    @Override
    public WorkflowStepStatus getStatus() {
        return this.stepStatus;
    }

    @Override
    public Mono<Boolean> process() {
        return this.webClient
                .post()
                .uri("/inventory/deduct")
                .body(BodyInserters.fromValue(this.requestDTO))
                .retrieve()
                .bodyToMono(InventoryResponseDTO.class)
                .map(r -> r.getStatus().equals(InventoryStatus.AVAILABLE))
                .doOnNext(b -> this.stepStatus = b ? WorkflowStepStatus.COMPLETE : WorkflowStepStatus.FAILED);
    }

    @Override
    public Mono<Boolean> revert() {
        return this.webClient
                    .post()
                    .uri("/inventory/add")
                    .body(BodyInserters.fromValue(this.requestDTO))
                    .retrieve()
                    .bodyToMono(Void.class)
                    .map(r ->true)
                    .onErrorReturn(false);
    }
}

Payment Steps:
package com.vinsguru.saga.service.steps;

import com.vinsguru.dto.PaymentRequestDTO;
import com.vinsguru.dto.PaymentResponseDTO;
import com.vinsguru.enums.PaymentStatus;
import com.vinsguru.saga.service.WorkflowStep;
import com.vinsguru.saga.service.WorkflowStepStatus;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public class PaymentStep implements WorkflowStep {

    private final WebClient webClient;
    private final PaymentRequestDTO requestDTO;
    private WorkflowStepStatus stepStatus = WorkflowStepStatus.PENDING;

    public PaymentStep(WebClient webClient, PaymentRequestDTO requestDTO) {
        this.webClient = webClient;
        this.requestDTO = requestDTO;
    }

    @Override
    public WorkflowStepStatus getStatus() {
        return this.stepStatus;
    }

    @Override
    public Mono<Boolean> process() {
        return this.webClient
                    .post()
                    .uri("/payment/debit")
                    .body(BodyInserters.fromValue(this.requestDTO))
                    .retrieve()
                    .bodyToMono(PaymentResponseDTO.class)
                    .map(r -> r.getStatus().equals(PaymentStatus.PAYMENT_APPROVED))
                    .doOnNext(b -> this.stepStatus = b ? WorkflowStepStatus.COMPLETE : WorkflowStepStatus.FAILED);
    }

    @Override
    public Mono<Boolean> revert() {
        return this.webClient
                .post()
                .uri("/payment/credit")
                .body(BodyInserters.fromValue(this.requestDTO))
                .retrieve()
                .bodyToMono(Void.class)
                .map(r -> true)
                .onErrorReturn(false);
    }

}
....................................................................................
				Order Service
....................................................................................
package com.vinsguru.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}

Configurations:
...............
package com.vinsguru.order.config;

import com.vinsguru.dto.OrchestratorRequestDTO;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

@Configuration
public class OrderConfig {

    @Bean
    public Sinks.Many<OrchestratorRequestDTO> sink(){
        return Sinks.many().unicast().onBackpressureBuffer();
    }

    @Bean
    public Flux<OrchestratorRequestDTO> flux(Sinks.Many<OrchestratorRequestDTO> sink){
        return sink.asFlux();
    }

}

Controller:
package com.vinsguru.order.controller;

import com.vinsguru.dto.OrderRequestDTO;
import com.vinsguru.dto.OrderResponseDTO;
import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("order")
public class OrderController {

    @Autowired
    private OrderService service;

    @PostMapping("/create")
    public Mono<PurchaseOrder> createOrder(@RequestBody Mono<OrderRequestDTO> mono){
        return mono
                .flatMap(this.service::createOrder);
    }

    @GetMapping("/all")
    public Flux<OrderResponseDTO> getOrders(){
        return this.service.getAll();
    }

}
Entity:
package com.vinsguru.order.entity;

import com.vinsguru.enums.OrderStatus;
import lombok.Data;
import lombok.ToString;
import org.springframework.data.annotation.Id;
import java.util.UUID;

@Data
@ToString
public class PurchaseOrder {

    @Id
    private UUID id;
    private Integer userId;
    private Integer productId;
    private Double price;
    private OrderStatus status;

}
OrderEventHandler:
package com.vinsguru.order.eventhandlers;

import com.vinsguru.dto.OrchestratorRequestDTO;
import com.vinsguru.dto.OrchestratorResponseDTO;
import com.vinsguru.order.service.OrderEventUpdateService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.DirectProcessor;
import reactor.core.publisher.Flux;

import java.util.function.Consumer;
import java.util.function.Supplier;

@Configuration
public class OrderEventHandler {

    @Autowired
    private Flux<OrchestratorRequestDTO> flux;

    @Autowired
    private OrderEventUpdateService service;

    @Bean
    public Supplier<Flux<OrchestratorRequestDTO>> supplier(){
        return () -> flux;
    };

    @Bean
    public Consumer<Flux<OrchestratorResponseDTO>> consumer(){
        return f -> f
                .doOnNext(c -> System.out.println("Consuming :: " + c))
                .flatMap(responseDTO -> this.service.updateOrder(responseDTO))
                .subscribe();
    };

}
Repository:
package com.vinsguru.order.repository;

import com.vinsguru.order.entity.PurchaseOrder;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import org.springframework.stereotype.Repository;

import java.util.UUID;

@Repository
public interface PurchaseOrderRepository extends ReactiveCrudRepository<PurchaseOrder, UUID> {
}

ServiceImpl
package com.vinsguru.order.service;

import com.vinsguru.dto.OrchestratorResponseDTO;
import com.vinsguru.order.repository.PurchaseOrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Service
public class OrderEventUpdateService {

    @Autowired
    private PurchaseOrderRepository repository;

    public Mono<Void> updateOrder(final OrchestratorResponseDTO responseDTO){
        return this.repository.findById(responseDTO.getOrderId())
                .doOnNext(p -> p.setStatus(responseDTO.getStatus()))
                .flatMap(this.repository::save)
                .then();
    }

}
package com.vinsguru.order.service;

import com.vinsguru.dto.OrchestratorRequestDTO;
import com.vinsguru.dto.OrderRequestDTO;
import com.vinsguru.dto.OrderResponseDTO;
import com.vinsguru.enums.OrderStatus;
import com.vinsguru.order.entity.PurchaseOrder;
import com.vinsguru.order.repository.PurchaseOrderRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Sinks;

import java.util.Map;

@Service
public class OrderService {

    // product price map
    private static final Map<Integer, Double> PRODUCT_PRICE =  Map.of(
            1, 100d,
            2, 200d,
            3, 300d
    );

    @Autowired
    private PurchaseOrderRepository purchaseOrderRepository;

    @Autowired
    private Sinks.Many<OrchestratorRequestDTO> sink;

    public Mono<PurchaseOrder> createOrder(OrderRequestDTO orderRequestDTO){
        return this.purchaseOrderRepository.save(this.dtoToEntity(orderRequestDTO))
                .doOnNext(e -> orderRequestDTO.setOrderId(e.getId()))
                .doOnNext(e -> this.emitEvent(orderRequestDTO));
    }

    public Flux<OrderResponseDTO> getAll() {
        return this.purchaseOrderRepository.findAll()
                .map(this::entityToDto);
    }

    private void emitEvent(OrderRequestDTO orderRequestDTO){
        this.sink.tryEmitNext(this.getOrchestratorRequestDTO(orderRequestDTO));
    }

    private PurchaseOrder dtoToEntity(final OrderRequestDTO dto){
        PurchaseOrder purchaseOrder = new PurchaseOrder();
        purchaseOrder.setId(dto.getOrderId());
        purchaseOrder.setProductId(dto.getProductId());
        purchaseOrder.setUserId(dto.getUserId());
        purchaseOrder.setStatus(OrderStatus.ORDER_CREATED);
        purchaseOrder.setPrice(PRODUCT_PRICE.get(purchaseOrder.getProductId()));
        return purchaseOrder;
    }

    private OrderResponseDTO entityToDto(final PurchaseOrder purchaseOrder){
        OrderResponseDTO dto = new OrderResponseDTO();
        dto.setOrderId(purchaseOrder.getId());
        dto.setProductId(purchaseOrder.getProductId());
        dto.setUserId(purchaseOrder.getUserId());
        dto.setStatus(purchaseOrder.getStatus());
        dto.setAmount(purchaseOrder.getPrice());
        return dto;
    }

    public OrchestratorRequestDTO getOrchestratorRequestDTO(OrderRequestDTO orderRequestDTO){
        OrchestratorRequestDTO requestDTO = new OrchestratorRequestDTO();
        requestDTO.setUserId(orderRequestDTO.getUserId());
        requestDTO.setAmount(PRODUCT_PRICE.get(orderRequestDTO.getProductId()));
        requestDTO.setOrderId(orderRequestDTO.getOrderId());
        requestDTO.setProductId(orderRequestDTO.getProductId());
        return requestDTO;
    }

}
...................................................................................
			Payment service
....................................................................................

package com.vinsguru.payment;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PaymentApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentApplication.class, args);
    }

}
package com.vinsguru.payment.controller;

import com.vinsguru.dto.PaymentRequestDTO;
import com.vinsguru.dto.PaymentResponseDTO;
import com.vinsguru.payment.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("payment")
public class PaymentController {

    @Autowired
    private PaymentService service;

    @PostMapping("/debit")
    public PaymentResponseDTO debit(@RequestBody PaymentRequestDTO requestDTO){
        return this.service.debit(requestDTO);
    }

    @PostMapping("/credit")
    public void credit(@RequestBody PaymentRequestDTO requestDTO){
        this.service.credit(requestDTO);
    }

}
package com.vinsguru.payment.service;

import com.vinsguru.dto.PaymentRequestDTO;
import com.vinsguru.dto.PaymentResponseDTO;
import com.vinsguru.enums.PaymentStatus;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.HashMap;
import java.util.Map;

@Service
public class PaymentService {

    private Map<Integer, Double> userBalanceMap;

    @PostConstruct
    private void init(){
        this.userBalanceMap = new HashMap<>();
        this.userBalanceMap.put(1, 1000d);
        this.userBalanceMap.put(2, 1000d);
        this.userBalanceMap.put(3, 1000d);
    }

    public PaymentResponseDTO debit(final PaymentRequestDTO requestDTO){
        double balance = this.userBalanceMap.getOrDefault(requestDTO.getUserId(), 0d);
        PaymentResponseDTO responseDTO = new PaymentResponseDTO();
        responseDTO.setAmount(requestDTO.getAmount());
        responseDTO.setUserId(requestDTO.getUserId());
        responseDTO.setOrderId(requestDTO.getOrderId());
        responseDTO.setStatus(PaymentStatus.PAYMENT_REJECTED);
        if(balance >= requestDTO.getAmount()){
            responseDTO.setStatus(PaymentStatus.PAYMENT_APPROVED);
            this.userBalanceMap.put(requestDTO.getUserId(), balance - requestDTO.getAmount());
        }
        return responseDTO;
    }

    public void credit(final PaymentRequestDTO requestDTO){
        this.userBalanceMap.computeIfPresent(requestDTO.getUserId(), (k, v) -> v + requestDTO.getAmount());
    }

}
application.properties
server.port=8082
.....................................................................................
				Inventory Application
.....................................................................................

package com.vinsguru.inventory;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryApplication {

    public static void main(String[] args) {
        SpringApplication.run(InventoryApplication.class, args);
    }

}
.........................................
package com.vinsguru.inventory.controller;

import com.vinsguru.dto.InventoryRequestDTO;
import com.vinsguru.dto.InventoryResponseDTO;
import com.vinsguru.inventory.service.InventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("inventory")
public class InventoryController {

    @Autowired
    private InventoryService service;

    @PostMapping("/deduct")
    public InventoryResponseDTO deduct(@RequestBody final InventoryRequestDTO requestDTO){
        return this.service.deductInventory(requestDTO);
    }

    @PostMapping("/add")
    public void add(@RequestBody final InventoryRequestDTO requestDTO){
        this.service.addInventory(requestDTO);
    }

}
package com.vinsguru.inventory.service;

import com.vinsguru.dto.InventoryRequestDTO;
import com.vinsguru.dto.InventoryResponseDTO;
import com.vinsguru.enums.InventoryStatus;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.HashMap;
import java.util.Map;

@Service
public class InventoryService {

    private Map<Integer, Integer> productInventoryMap;

    @PostConstruct
    private void init(){
        this.productInventoryMap = new HashMap<>();
        this.productInventoryMap.put(1, 5);
        this.productInventoryMap.put(2, 5);
        this.productInventoryMap.put(3, 5);
    }

    public InventoryResponseDTO deductInventory(final InventoryRequestDTO requestDTO){
        int quantity = this.productInventoryMap.getOrDefault(requestDTO.getProductId(), 0);
        InventoryResponseDTO responseDTO = new InventoryResponseDTO();
        responseDTO.setOrderId(requestDTO.getOrderId());
        responseDTO.setUserId(requestDTO.getUserId());
        responseDTO.setProductId(requestDTO.getProductId());
        responseDTO.setStatus(InventoryStatus.UNAVAILABLE);
        if(quantity > 0){
            responseDTO.setStatus(InventoryStatus.AVAILABLE);
            this.productInventoryMap.put(requestDTO.getProductId(), quantity - 1);
        }
        return responseDTO;
    }

    public void addInventory(final InventoryRequestDTO requestDTO){
        this.productInventoryMap
                .computeIfPresent(requestDTO.getProductId(), (k, v) -> v + 1);
    }

}
.....................................................................................
				Transactional messaging 
....................................................................................
	
As we have seen before, we can enable transactions for database to achive higher consistency.

Can we enable transactions for Message flows like kafka?

No!


One of the APIs in the microservice does two operations:

1.update a database
2.send a message to another service

How can you make sure both are transactional?


In other words if database update fails don’t send the message to the other service and if message sending fails rollback the database update?


In Spring you handle transactions using the @Transactional annotation.

But this works only at the database level.

If you are sending a message to another service preferrable in an asynchronous way then the annotation wont work.

Distributed Transactions (XA) may not work since messaging systems like Apache Kafka don’t support them.

A solution to the above problem is the "Transactional Outbox pattern".
......

An Use Case explaining the problem
What is transactional outbox pattern?
Transactional outbox with Polling publisher
Transactional outbox with Transaction Log Trailing
Implementation in Spring Boot


An Use Case:
Let’s say you run a coffee shop.

You have an application to take orders for coffee.

Customer places an order at the entrance and then goes to the barista to collect it.

You have a bunch of microservices to manage your coffee shop.

And one of them is to take orders .

The “Order Service” stores an order in database as soon as an order is placed and sends an asynchronous message to the barista “Delivery Service” to prepare the coffee and give it to the customer.

You have kept the delivery part to the barista(“delivery service”) as asynchronous for scalability.


Now,

Let’s say a customer places an order and order is inserted into the order database.

While sending the message to the “Delivery Service” some exception happens and the message is not sent.

The order entry is still in the database though leaving the system in an inconsistent state.

Ideally you would roll back the entry in the orders database since placing the order and sending an event to the delivery service are part of the same transaction.

But how do you implement transaction across two different types of systems :


A database and A messaging service.

Such a scenario is quite common in the microservices world.

If the two operations are database operations it would be easy to handle the transaction. Use @Transactional annotation provided by Spring Data.

Here the scenario is different.

And hence the solution is:

			"Use Transactional Outbox pattern"

What is Transactional Outbox pattern?

Transactional Outbox pattern mandates that you create an “Outbox” table to keep track of the asynchronous messages. For every asynchronous message, you make an entry in the “Outbox” table. You then perform the database operation and the “Outbox” insert operations as part of the same transaction.

This way if an error happens in any of the two operations the transaction is rolled back.

You then pick up the messages from the ‘Outbox’ and deliver it to your messaging system like Apache Kafka.

Also once the message is delivered delete the entry from the Outbox so that it is not processed again.

So let’s say you perform two different operations in the below order as part of a single transaction:

1.Database Insert
2.Asynchronous Message (Insert into Outbox table)

If step 1 fails anyway exception will be thrown and step 2 won’t happen.

If step 1 succeeds and step 2 (insert into outbox table) fails the transaction will be rolled back.


If the order of operations are reversed:

Asynchronous Message (Insert into Outbox table)
Database Insert
Then if step 1 fails similar to the previous case exception will be thrown and step 2 won’t happen.

If step 1 succeeds and step 2 (Database Insert) fails then the transaction will be rolled back and the entry in Outbox table will be removed. Since it is part of the same transaction , the insert into Outbox table earlier was not committed and hence the asynchronous message won’t be sent.


In our case ,

When a customer places an order , we make an entry in Orders database and another entry in Outbox table.

Once the above transaction completes we pick up the messages from the Outbox table and send it the “Delivery Service”. Notice that if some error happens and the “Delivery Service” did not receive the message , the messaging system like Apache Kafka will automatically retry to deliver the message.


That summarizes the Outbox pattern.

Now there are two ways to pick up the messages from the Outbox and deliver it to the external service.

1.Polling Publisher
2.Transaction Log tailing.
Let’s see each of them.


Polling Publisher

	In Polling Publisher pattern you periodically poll the “Outbox” table , pick the messages , deliver to the messaging service and delete the entry from the Outbox table.

You can use Spring Batch or Spring Scheduler (@Scheduled annotation) to implement this.

The drawback with this method is polling is an expensive operation.

Also you block the table while polling it.

And if you use a non relational database like MongoDB polling could get complicated.


Transaction Log tailing:

Hence the second way – “Transaction Log Trailing” is a better option to implement this .

Transaction Log Trailing
In Transaction Log Trailing instead of polling the table , you read the database logs.

Every commit made to a table is written to a database transaction log.

So instead of reading the table you read the log as soon as an entry is made .

This way the table is not blocked and you can avoid expensive database polling.
...................................................................................
	  Transaction outbox pattern with Transaction Log tailing pattern
		     (CDC- Change Data Capture)
.....................................................................................

Tools like “Debezium” help in capturing database transaction logs.


Let’s see how to implement Transactional Outbox pattern with Transaction Log Tailing in Spring Boot using Debezium.

Implementation:
Let’s create two microservices:

“orderservice”

“deliveryservice”


Let’s create an order through orders service. And then let’s publish an event that order has been created. Both these need to be part of the same transaction.


delivery service will read this event and perform the necessary delivery logic. We will not deal with the delivery logic , we will just read the message sent by order service for this example.

The order service
Create a spring boot application with spring-boot-starter-web , spring-boot-starter-data-jpa and mysql-connector-java (since we are connecting to mysql database in this example)

...................

Steps:
1.Start Zookeeper
2.Start Kafka
3.Start a MySQL database
4.Start a MySQL command line client
5.Start Kafka Connect


Apache Zookeeper:


docker run -it --rm --name zookeeper -p 2181:2181 -p 2888:2888 -p 3888:3888 quay.io/debezium/zookeeper:1.9


Apache Kafka:


docker run -it --rm --name kafka -p 9092:9092 --link zookeeper:zookeeper quay.io/debezium/kafka:1.9
MySQL:


docker run -it --rm --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root mysql

MySQL Client:

1
docker run -it --rm --name mysqlterm --link mysql --rm mysql sh -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'

Once you set up MySQL client you can create the order and outbox tables.


Kafka connector:

1
docker run -it --rm --name connect -p 8083:8083 -e GROUP_ID=1 -e CONFIG_STORAGE_TOPIC=my_connect_configs -e OFFSET_STORAGE_TOPIC=my_connect_offsets -e STATUS_STORAGE_TOPIC=my_connect_statuses --link zookeeper:zookeeper --link kafka:kafka --link mysql:mysql quay.io/debezium/connect:1.9


Once the Kafka Connector is set up , you need to activate debezium connector.

To do that you just need to hit a connector REST API 
(http://localhost:8083/connectors) with the below request:


{
    "name": "orders-connecter",
    "config": {
        "connector.class": "io.debezium.connector.mysql.MySqlConnector",
        "tasks.max": "1",
        "database.hostname": "host.docker.internal",
        "database.port": "3307",
        "database.user": "root",
        "database.password": "root",
        "database.server.id": "100",
        "database.server.name": "orders_server",
        "database.include.list": "orders",
        "table.include.list":"orders.outbox",
        "database.history.kafka.bootstrap.servers": "kafka:9092",
        "database.history.kafka.topic": "schema_changes.orders",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState"
    }
}


As you notice in the request , I have included “orders” database and then “orders.outbox” table for transaction log trailing in the above request using “database.include.list” and “table.include.list” properties respectively. You give your own name to the database server (orders_server in the above case).

Once you make the request , Kafka will start sending events for every database operation on the table outbox. Debezium will keep reading the database logs and send those events to Apache Kafka through Kafka Connector.


Now you need to listen for this event in your “deliveryservice” for the topic “orders_server.orders.outbox” (server name + table name)


As you notice in the request , I have included “orders” database and then “orders.outbox” table for transaction log trailing in the above request using “database.include.list” and “table.include.list” properties respectively. You give your own name to the database server (orders_server in the above case).

Once you make the request , Kafka will start sending events for every database operation on the table outbox. Debezium will keep reading the database logs and send those events to Apache Kafka through Kafka Connector.


Now you need to listen for this event in your “deliveryservice” for the topic “orders_server.orders.outbox” (server name + table name)

The Delivery Service:
Create a spring boot application with spring-kafka dependency.

Here is a sample pom.xml:

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.7</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>delivery</artifactId>
    <version>1.0.0</version>
    <name>kafkaconsumer</name>
    <description>Demo project for Transactional Messaging</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
 
     
    </dependencies>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
 
</project>
Ezoic
Create a configuration class to configure the Kafka Server details and the deserializer (how to deserialize the message sent by Kafka):

package com.example.delivery;
 
import java.util.HashMap;
import java.util.Map;
 
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.support.serializer.JsonDeserializer;
 
@Configuration
@EnableKafka
public class ReceiverConfig {
 
    @Bean
    public Map<String, Object> consumerConfigs() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "host.docker.internal:9092");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "json");
 
        return props;
    }
 
    @Bean
    public ConsumerFactory<String, KafkaMessage> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(consumerConfigs(), new StringDeserializer(),
                new JsonDeserializer<>(KafkaMessage.class));
    }
 
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, KafkaMessage> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, KafkaMessage> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
 
        return factory;
    }
 
}
Create a service class which listens for the messages sent by Kafka:

package com.example.delivery;
 
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;
 
@Service
public class DeliveryService {
 
     
    @KafkaListener(topics = "orders_server.orders.outbox")
    public void receive(KafkaMessage message) {
         
         
        System.out.println(message);
    }
}

Notice the topic we are listening for. We are just printing the message here. In real time we would be performing the delivery logic here.


Here is the KafkaMessage domain object which represent the Kafka Message:

package com.example.delivery;
 
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
 
@JsonIgnoreProperties(ignoreUnknown = true)
public class KafkaMessage {
     
     
    private PayLoad payload;
 
    public PayLoad getPayload() {
        return payload;
    }
 
    public void setPayload(PayLoad payload) {
        this.payload = payload;
    }
 
    @Override
    public String toString() {
        return "KafkaMessage [payload=" + payload + "]";
    }
     
     
     
 
}
 
@JsonIgnoreProperties(ignoreUnknown = true)
 class PayLoad{
     
     
    int id;
     
    String event;
     
    @JsonProperty("event_id")
    int eventId;
     
     
    String payload;
     
    @JsonProperty("created_at")
    String createdAt;
 
    public int getId() {
        return id;
    }
 
    public void setId(int id) {
        this.id = id;
    }
 
    public String getEvent() {
        return event;
    }
 
    public void setEvent(String event) {
        this.event = event;
    }
 
    public int getEventId() {
        return eventId;
    }
 
    public void setEventId(int eventId) {
        this.eventId = eventId;
    }
 
    public String getPayload() {
        return payload;
    }
 
    public void setPayload(String payload) {
        this.payload = payload;
    }
 
    public String getCreatedAt() {
        return createdAt;
    }
 
    public void setCreatedAt(String createdAt) {
        this.createdAt = createdAt;
    }
 
    @Override
    public String toString() {
        return "PayLoad [id=" + id + ", event=" + event + ", eventId=" + eventId + ", payload=" + payload
                + ", createdAt=" + createdAt + "]";
    }
     
     
     
}
Kafka Message contains a lot of info , we are just interested in the “payload” object and it is mapped in the above domain object.

Since the above app interacts with Kafka and I used docker images to build those , I built a docker image for this service as well (it gets complicated to interact with Kafka inside a docker container from outside).

The below command builds a docker image for the above spring boot app.

1
mvnw clean install spring-boot:build-image
It created an image under the name deliveryservice:1.0.0

The below command runs the docker image:

1
docker run -it --rm deliveryservice:1.0.0
Testing
Now let’s test our changes.


Create a new order by hitting the orderservice API:


And notice a message in the delivery service API!

1
KafkaMessage [payload=PayLoad [id=1, event=order_created, eventId=1, payload={"name":"Latte Coffee","quantity":5}, createdAt=2022-05-19T15:03:41Z]]

The delivery service can then start storing these orders internally in its own tables and start preparing coffee for each order and deliver it in their own time
.....................................................................................
			  CQRS - Command Query Responsibility Segregation
................................................................................

You have applied the Microservices architecture pattern and the Database per service pattern.
    As a result, it is no longer straightforward to implement queries that join data from multiple services. 
    Also, if you have applied the Event sourcing pattern then the data is no longer easily queried.

Soultion:
 
Most of application are CURD in nature. when we design these applications, we create entity classes and corresponding repository classes for CURD operations.

Read and write:
 Most of the applications read more , than write...

Read vs write traffic point of view, read traffic is always heavy.

Command Query Responsibility Segregation:
........................................

Command - modifes the data and does not return any Anything(Write)
Query  - does not modify the data but returns data(Read)

You are going to break application into microservice of an exsiting service into based on CQRS Pattern..

                             OrderApplication
       				 |
	  OrderCommandApp(command)        OrderQueryApp(Query)


Database Design for OrderApplication:
.....................................

Level-1

 OrderApplication
     |
 OrderDatabase

Level-2
			 OrderApplication
       				 |
	  OrderCommandApp(command)        OrderQueryApp(Query)
				 |
		---------------------------------------
				|
			   Order database


Level-3 : Database Per service pattern


			 OrderApplication
       				 |
	  OrderCommandApp(command)        OrderQueryApp(Query)
				 |
		----------------   ----------------------
		|                               |
            orderMaster                      OrderHistory

			    EventSourcing
			 Transactional outbox
				|
			      Kafka


